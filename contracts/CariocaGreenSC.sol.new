// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./CariocaGreenTreeToken.sol";
import "./RioIPTUToken.sol";

contract CariocaGreenSC is Ownable {

    address contractOwner;                                  // Save contract owner

    uint creditsPerPlantedTree;                             // Store number of credits (RIPTUs) per planted tree (CGT)
    CariocaGreenTreeToken private cariocaGreenTreeToken;     // Instantiate CariocaGreenTreeToken smart contract
    RioIPTUToken private rioIPTUToken;                       // Instatiate RioIPTUToken smart contract
    
    mapping(address => uint) totalPlantedTrees;             // Store total number of trees (CGTs) planted by each citizen
    mapping(address => uint) totalCredits;                  // Store total number of credits (RIPTUs) owned by each citizen

    event CariocaGreenSCCreated(address indexed owner);                                               // Event to register smart contract creation
    event PlantedTreeRegistered(address indexed citizen, uint indexed trees, uint indexed credits);   // Event to register a new planted tree registration
    event PlantedTreeUnRegistered(address indexed citizen, uint indexed trees, uint indexed credits); // Event to register credits registration


    constructor(uint _creditsPerPlantedTree) Ownable(msg.sender) {
        require(_creditsPerPlantedTree > 0, "Total number of credits per Tree must be greater than zero");

        contractOwner = msg.sender;
        creditsPerPlantedTree = _creditsPerPlantedTree;
        cariocaGreenTreeToken = new CariocaGreenTreeToken(msg.sender);
        rioIPTUToken = new RioIPTUToken(msg.sender);

        emit CariocaGreenSCCreated(msg.sender);
    }

    function chainMintCGT (address _to) public onlyOwner {
        cariocaGreenTreeToken.safeMint(_to);                // Mint token NFT CGT
    }

    function chainMintRIPTU (address _to) public onlyOwner {
        rioIPTUToken.mint(_to, creditsPerPlantedTree);      // Mint tokens RIPTU
    }

    function chainDestroyCGT (address _to) public onlyOwner {
        cariocaGreenTreeToken.safeMint(_to);                // Destroy token NFT CGT
    }

    function chainDestroyRIPTU (address _to) public onlyOwner {
        rioIPTUToken.mint(_to, creditsPerPlantedTree);      // Destroy tokens RIPTU
    }

    function chainTransferRIPTU (address _from, address _to, uint _amount) public onlyOwner {
        rioIPTUToken.transfer(_from, _to, _amount);
    }

    function balanceOf (address wallet) public onlyOwner {
        return this.balanceOf(wallet);
    }

    // Contract owner call this funtion to register a new planted tree
    function registerPlantedTree(address _address) public onlyOwner returns (uint){
      totalPlantedTrees[_address]  += 1;
      totalCredits[_address] += creditsPerPlantedTree;

      chainMintCGT(_address);
      chainMintRIPTU(_address);

      emit PlantedTreeRegistered(_address, totalPlantedTrees[msg.sender], totalCredits[msg.sender]);

      return totalPlantedTrees[_address];
    }

    // Contract owner call this funtion to unregister a new planted tree
    function destroyPlantedTree(address _address) public onlyOwner {
      require(totalPlantedTrees[msg.sender] > 0, "Citizen does not have any planted tree.");

      totalPlantedTrees[msg.sender]  -= 1;
      totalCredits[msg.sender] -= creditsPerPlantedTree;

      emit PlantedTreeUnRegistered(_address, totalPlantedTrees[msg.sender], totalCredits[msg.sender]);
    }

    // Citizen call this funtion to get his total number of planted trees
    function getPlantedTrees(address _address) public view returns (uint){
      require(msg.sender == contractOwner || msg.sender == _address, "Only own citizen or contract owner can call this function.");

      return (totalPlantedTrees[_address]);
    }

    // Citizen call this funtion to get his total number of credits
    function getTotalCredits(address _address) public view returns (uint){
      require(msg.sender == contractOwner || msg.sender == _address, "Only own citizen or contract owner can call this function.");

      return(totalCredits[_address]);
    }

    // Citizen call this funtion to get his total number of credits
    function transferCredits(address _to, uint _amount) public returns (uint){
      require(totalCredits[msg.sender] >= _amount, "Citizen does not have enough credits to transfer.");

      totalCredits[msg.sender] -= _amount;
      totalCredits[_to] += _amount;
      return(totalCredits[msg.sender]);
    }
}
